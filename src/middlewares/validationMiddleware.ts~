import { body, validationResult } from 'express-validator';
import { Request, Response, NextFunction, RequestHandler } from 'express';
import User from '../models/user';

export const validateUser: RequestHandler[] = [
    // Validação para o campo 'nome'
    body('nome')
        .isString()
        .withMessage('Nome deve ser um texto')
        .isLength({ min: 3 })
        .withMessage('Nome deve ter pelo menos 3 caracteres'),

    // Validação para o campo 'email'
    body('email')
        .isEmail()
        .withMessage('Email deve ser válido')
        .custom(async (value, { req }) => {
            const user = await User.findOne({ where: { email: value } });
            const userId = req.params?.id; // Obtém o ID do usuário dos parâmetros da rota

            if (user && (req.method !== 'PATCH' || user.id !== userId)) {
                // Se for um método diferente de PATCH ou se o e-mail pertencer a outro usuário, rejeita
                return Promise.reject('Email já está em uso');
            }
        }),

    // Validação para o campo 'idade'
    body('idade')
        .isInt()
        .withMessage('Idade deve ser um número inteiro')
        .isInt({ min: 1 })
        .withMessage('Idade deve ser pelo menos 1'),

    // Validação para o campo 'ativo' e é opcional
    body('ativo')
        .optional()
        .isBoolean()
        .withMessage('Ativo deve ser um valor booleano'),

    // Validação para verificar se o parâmetro 'id' é um UUID
    body('id')
        .optional()
        .isUUID()
        .withMessage('Id deve ser um UUID'),

    // Middleware para lidar com os erros de validação
    (req: Request, res: Response, next: NextFunction): void => {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            res.status(400).json({ errors: errors.array() });
        } else {
            next();
        }
    },
];